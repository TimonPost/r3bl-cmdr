‚ñ† r3bl-cmdr ‚ñ†

think about containers, containment, and keyboard focus management:
  ‚úî move cursor to relative & absolute (üî± move-cursor-rel-abs) @done(22-07-17 11:53)
    - the pos + size of a box is provided to a *component* 
    - the *component* paints itself thinking it starts at 0, 0 
    - the *component* is actually relative to the box when it is rendered 
    - add TWCommands to handle above: 
      - `MoveCursorPositionAbs(Position)`
      - `MoveCursorPositionRelTo(Position, Position)`
    - rename `Render` to `TWApp`
  ‚úî add support for focus management to state (üî± state-focus-mgmt) @done(22-07-19 11:03)
    - need to accommodate handling of focus & what is currently in focus
    - introduce trait `StateManageFocus` w/ 2 methods: 
      - `get_focus_id(): str`
      - `set_focus_id(id: str)`
  ‚úî add new trait `RenderComponent` (üî± better-box-containment) @done(22-07-21 17:45)
    - files: 
      - `tw_surface.rs`, 
      - `tw_app.rs`, 
      - `app_with_layout.rs`
    - separate the logic of painting from the app
    - take box-origin-pos & content-size as input?
    - paint things that are relative to box-origin-pos?
    - each component should handle its own input event (when it has focus)
  ‚òê handle graphemes in truncate 
    - currently in `Size`, should be moved into separate module
  ‚òê clean up old stuff that has been replace by `RenderComponent`
  ‚òê route input events based on who has focus
  ‚òê what should the specificity of input event handling be? (üî± input-event-specificity)
    - Currently the `DefaultInputEventHandler` does not consume input events and it peeks at them
    - There isn't a way for apps to override any container defaults
    - Should this be inverted? Apps get first dibs input event & consume if they handle it?

add layout engine:
  ‚úî merge `tw_area_test.rs` + `app_without_layout.rs` -> `app_with_layout.rs` @done(22-07-03 16:47)
  ‚úî make sure to save `app_without_layout.rs` for future use w/ routing below @done(22-07-03 16:26)
  ‚úî rename `tw_area.rs` to `tw_surface` and `TWArea` to `TWSurface` @done(22-07-04 20:27)
  ‚òê paint state & use lolcat
  
test 2 col layout:
  ‚úî refactor DEBUG & raw mode & TWCommand @done(22-07-04 20:06)
  ‚úî make sure that the colors work as expected (Color::Red, Color::Rgb, etc) @done(22-07-03 19:43)
  ‚úî row calculation seems wrong (too much space on top of the rendered output) @done(22-07-04 15:10)
  ‚úî clean up decl macros w/ repetitions `tw_command.rs`, `file_logging.rs`, `decl_macros.rs` @done(22-07-04 20:23)
  ‚úî emit clear screen & reset color commands before rendering each frame (artifacts appear on resize) @done(22-07-04 21:00)
  ‚úî does margin (cols) work as expected? (different in vscode terminal vs real terminal) @done(22-07-07 13:41)
  ‚òê make sure that the attributes work as expected (dim, strike through, etc)
  ‚òê handle situation when cursor is moved PAST the bounds of the window (< 0 or > max)
    - add row and col offset?
    - track cursor position?
    - Example: https://github.com/nazmulidris/cli-editor/blob/main/src/main.rs

performance & completeness:
  ‚òê stress test app w/ full screen repaint on mouse move
  ‚òê add all the remaining crossterm commands to `TWCommand`
  
introduce first DSL (JSX-like syntax):
  ‚úî implement `style!` proc macro as first DSL JSX like syntax for TUI @done(22-07-06 15:29)
  ‚úî split `tui_core` from `tui` and move it into `r3bl_rs_utils` @done(22-07-06 15:29)
  ‚úî replace all use of `Style` with this macro @done(22-07-06 16:05)
  ‚òê write DL tutorial on create DSL in Rust
    - based on: https://github.com/r3bl-org/r3bl-rs-utils/blob/main/macro/src/make_style/mod.rs
    - create tui category in DL
    - make sure to publicize this article on mailchimp, reddit, users.rust-lang.org

routing:
  ‚òê introduce routing concept to switch between apps (with + without layout)

focus mgmt:
  ‚òê figure out keyboard focus management
  ‚òê what does input event routing look like?
  ‚òê extend state to have a focus field (current id w/ focus)
  ‚òê how does this affect rendering of a layout (paint focus highlight?)
  ‚òê key input processing & state mgmt (redux?)
  ‚òê implement simplest editor component (single line text field)
  ‚òê implement simplest checkbox selection component (modal?)

support for graphemes & text wrapping:
  ‚òê `unicode-width` crate
  ‚òê `textwrap` crate
  ‚òê Update `tw_surface.rs::print_inside_box()` to support graphemes & text wrapping

pre built components - editor:
  ‚òê scrolling: data buffer, cursor pos (row, col), scrolling (row offset, col offset)
    - [src](https://github.com/nazmulidris/cli-editor/blob/main/src/main.rs)
    - [viewer tutorial](https://medium.com/@otukof/build-your-text-editor-with-rust-part-4-fd4a8b8641f8)
    - [editor tutorial](https://medium.com/@otukof/build-your-text-editor-with-rust-part-5-e363c16f542b)
    - [search tutorial](https://medium.com/@otukof/build-your-text-editor-with-rust-part-6-3cff61dc2de5)
    - [syntax highlighting tutorial](https://medium.com/@otukof/build-your-text-editor-with-rust-final-part-4c841a649900)
  ‚òê undo & redo

pre built components - multi select chooser:
  ‚òê TODO

pre built components - autocompletion provider:
  ‚òê TODO

mdns & p2p:
  ‚òê Ideate on what this might look like
    - local service discovery
    - easy authentication (cloud auth provider login?)

new stuff:
  ‚òê flow editor
  ‚òê diagrams
