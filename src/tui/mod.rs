/*
 *   Copyright (c) 2022 R3BL LLC
 *   All rights reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

// FIXME: clean content below up
// FIXME: copy some of this content over to the r3bl_rs_utils
// FIXME: add background information on PTY, VT100 (from tui::crossterm_helper::mod.rs)
// FIXME: add background information on terminals (from Mosaic video)
// FIXME: move lolcat module to r3bl_rs_utils_core::tui module
// FIXME: move tui module to r3bl_rs_utils::tui module

//! # tui package
//!
//! You can build fully async TUI apps with a modern API that brings the best of reactive &
//! unidirectional data flow architecture from frontend web development (React, Redux, CSS, flexbox)
//! to Rust and TUI apps. And since this is using Tokio you get the advantages of concurrency and
//! parallelism built-in. No more blocking on the main thread for user input, for async middleware,
//! or even rendering 🎉.
//!
//! This framework is [loosely coupled and strongly
//! coherent](https://developerlife.com/2015/11/05/loosely-coupled-strongly-coherent/) meaning that
//! you can pick and choose whatever pieces you would like to use w/out having the cognitive load of
//! having to grok all the things in the codebase. Its more like a collection of mostly independent
//! modules that work well w/ each other, but know very little about each other.
//!
//! Here are some framework highlights:
//! - The entire TUI framework itself supports concurrency & parallelism (user input, rendering,
//!   etc. are generally non blocking).
//! - Flexbox-like responsive layout.
//! - CSS-like styling.
//! - Redux for state management (fully async, concurrent & parallel).
//! - Lolcat implementation w/ a rainbow color-wheel palette.
//! - Support for Unicode grapheme clusters in strings.
//!
//! ## Life of an input event
//!
//! There is a clear separation of concerns in this module. To illustrate what goes where, let's
//! look at an example.
//! - The diagram below shows an app that has 3 [Component]s for (flexbox like) layout & (CSS like)
//! styling.
//! - Let's say that you run this app (by hypothetically executing `cargo run`).
//! - And then you click or type something in the terminal window that you're running this app in.
//!
//! ```text
//! input event → [TerminalWindow]
//!                   ↑      ↓                 [ComponentRegistry] creates
//!                   ┊   [TWApp] ───────────■ [Component]s at 1st render
//!                   ┊      │                 
//!                   ┊      │        ┌──────■ id=1 has focus
//!                   ┊      │        │
//!                   ┊      ├→ [Component] id=1 ───┐
//!                   ┊      ├→ [Component] id=2    │
//!                   ┊      └→ [Component] id=3    │
//!                default                          │
//!                handler  ←───────────────────────┘
//! ```
//!
//! Let's trace the journey through the diagram when an input even is generated by the user (eg: a
//! key press, or mouse event). Keep in mind that this input is collected in an async manner so
//! there are no threads blocked. This input is processed by the main loop of [TerminalWindow].
//!
//! 1. The [Component] that is in [TWBox] w/ `id=1` currently has focus.
//! 2. When an input event comes in from the user (key press or mouse input) it is routed to the
//!    [TWApp] first, before [TerminalWindow] looks at the event.
//! 3. The specificity of the event handler in [TWApp] is higher than the default input handler in
//!    [TerminalWindow]. Further, the specificity of the [Component] that currently has focus is the
//!    highest. In other words, the input event gets routed by the [TWApp] to the [Component] that
//!    currently has focus ([Component] id=1 in our example).
//! 4. Since it is not guaranteed that some [Component] will have focus, this input event can then
//!    be handled by [TWApp], and if not, then by [TerminalWindow]'s default handler. If the default
//!    handler doesn't process it, then it is simply ignored.
//! 5. In this journey, as the input event is moved between all these different entities, each
//!    entity decides whether it wants to handle the input event or not. If it does, then it returns
//!    an enum indicating that the event has been consumed, else, it returns an enum that indicates
//!    the event should be propagated.
//!
//! Now that we have seen this whirlwind overview of the life of an input event, let's look at the
//! details in each of the sections below.
//!
//! ## Layout and styling
//! TODO: window -> app -> component SOC (separation of concerns)
//!
//! ## [Component] and [ComponentRegistry]
//! TODO: window -> app -> component SOC (separation of concerns)
//!
//! ## Input event specificity
//! TODO: input event specificity (app overrides window defaults)
//!
//! ## Focus management and [HasFocus]
//! TODO: focus management (who has focus, each component has own cursor)
//!
//! ## Input event routing (by focus)
//! TODO: input event routing by focus
//!
//! ## Redux for state management
//! TODO:
//!
//! ## Grapheme support
//! TODO:
//!
//! ## Lolcat support
//! TODO:
//!

/// Use bitflags! macro.
extern crate bitflags;

// Attach sources.
pub mod crossterm_helpers;
pub mod layout;
pub mod lolcat;
pub mod terminal_window;

// Re-export.
pub use crossterm_helpers::*;
pub use layout::*;
pub use lolcat::*;
pub use terminal_window::*;
